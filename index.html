<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2次関数 最大・最小問題トレーニング【最終決定版】</title>
    <style>
        body { font-family: 'Helvetica Neue', 'Arial', 'Hiragino Sans', 'Meiryo', sans-serif; background-color: #f0f7ff; color: #333; max-width: 800px; margin: 20px auto; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); }
        h1, h2, h3 { text-align: center; color: #005a9c; }
        #setup, #problem-container, #final-result-container { background-color: #fff; padding: 25px; border-radius: 8px; margin-top: 20px; border: 1px solid #ddd; }
        .problem-header { font-size: 1.3em; font-weight: bold; text-align: center; margin-bottom: 20px; color: #003366; }
        .problem-statement, #explanation-problem-statement { font-size: 1.2em; font-weight: bold; line-height: 1.6; margin-bottom: 20px; text-align: center; padding: 10px; border: 1px solid #e0e0e0; background-color: #fafafa; border-radius: 5px;}
        .timer { position: fixed; top: 20px; right: 30px; font-size: 1.8em; font-weight: bold; color: #d9534f; background-color: #fff; padding: 10px 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .options { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 20px; }
        .option-btn { width: 100%; padding: 15px; font-size: 1em; cursor: pointer; border-radius: 5px; border: 2px solid #007bff; background-color: #fff; color: #007bff; transition: all 0.3s; }
        .option-btn:hover { background-color: #007bff; color: #fff; }
        .option-btn.correct { background-color: #28a745; color: white; border-color: #28a745; }
        .option-btn.incorrect { background-color: #dc3545; color: white; border-color: #dc3545; }
        .btn { display: block; width: 100%; padding: 15px; font-size: 1.1em; font-weight: bold; cursor: pointer; border-radius: 5px; border: none; margin-top: 10px; transition: background-color 0.3s; }
        #start-btn { background-color: #28a745; color: white; }
        #next-question-btn { background-color: #17a2b8; color: white; }
        #explanation { margin-top: 20px; padding: 20px; background-color: #e9ecef; border-radius: 5px; border-left: 5px solid #007bff; }
        .hidden { display: none; }
        label { font-weight: bold; margin-right: 10px; }
        input { padding: 8px; border-radius: 4px; border: 1px solid #ccc; width: calc(100% - 110px); }
        .graph-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 15px; }
    </style>
</head>
<body>
    <h1>2次関数 最大・最小問題トレーニング【最終決定版】</h1>
    <div class="timer hidden" id="timer-display">0.00</div>
    <div id="setup">
        <h2>問題設定</h2>
        <label for="name">ニックネーム:</label>
        <input type="text" id="name" placeholder="ランキング用の名前">
        <br><br>
        <button id="start-btn" class="btn">全3問 ランダム演習開始</button>
    </div>
    <div id="problem-container" class="hidden">
        <div id="problem-header" class="problem-header"></div>
        <div class="problem-statement" id="problem-statement"></div>
        <div class="options" id="options-container"></div>
        <div id="explanation" class="hidden">
            <h3 id="result-message"></h3>
            <div id="explanation-problem-statement"></div>
            <div id="explanation-text"></div>
            <div id="explanation-graphs" class="graph-container"></div>
        </div>
        <button id="next-question-btn" class="btn hidden">次の問題へ</button>
    </div>
    <div id="final-result-container" class="hidden">
        <h2>演習終了！</h2>
        <p style="text-align:center; font-size: 1.2em;">総解答時間: <span id="final-time"></span>秒</p>
        <p style="text-align:center; font-size: 1.2em;">正解数: <span id="final-score"></span></p>
        <a href="./ranking.html" target="_blank" class="btn" style="background-color:#6c757d; color:white; text-decoration: none; display: flex; align-items: center; justify-content: center;">ランキングを見る</a>
        <button onclick="location.reload()" class="btn">もう一度挑戦する</button>
    </div>

    <script>
        // DOM要素
        const setupDiv = document.getElementById('setup'); const problemContainer = document.getElementById('problem-container'); const finalResultContainer = document.getElementById('final-result-container'); const startBtn = document.getElementById('start-btn'); const problemHeader = document.getElementById('problem-header'); const problemStatement = document.getElementById('problem-statement'); const optionsContainer = document.getElementById('options-container'); const timerDisplay = document.getElementById('timer-display'); const explanationDiv = document.getElementById('explanation'); const resultMessage = document.getElementById('result-message'); const explanationProblemStatement = document.getElementById('explanation-problem-statement'); const explanationTextDiv = document.getElementById('explanation-text'); const explanationGraphsDiv = document.getElementById('explanation-graphs'); const nextQuestionBtn = document.getElementById('next-question-btn'); const finalTime = document.getElementById('final-time'); const finalScore = document.getElementById('final-score');
        
        // クイズの状態管理
        let timerInterval; let totalTime = 0; let startTime; let quizData = []; let currentQuestionIndex = 0; let score = 0;
        const TOTAL_QUESTIONS = 3; const problemTypes = ["moving_axis", "moving_domain_right", "moving_domain_left", "moving_domain_both", "moving_all_linked"];
        
        function formatTerm(coeff, variable = '', isFirst = false) {
            if (coeff === 0) return '';
            let sign = coeff > 0 ? ' + ' : ' - ';
            if (isFirst && coeff > 0) sign = '';
            if (isFirst && coeff < 0) sign = '-';
            const absCoeff = Math.abs(coeff);
            const coeffStr = absCoeff === 1 && variable ? '' : absCoeff;
            return `${sign}${coeffStr}${variable}`;
        }
        function renderMath(element) { if (window.MathJax) { MathJax.typesetPromise([element]).catch(console.error); } }
        function createSVGGraph(params) {
            const { down, axisPos, domainPos, label, caseText, domainStartLabel, domainEndLabel } = params; const viewBoxWidth = 240, viewBoxHeight = 170; const originX = viewBoxWidth / 2, originY = viewBoxHeight - 40;
            const parabolaPath = down ? `M ${axisPos-40},${originY+10} Q ${axisPos},${originY-80} ${axisPos+40},${originY+10}` : `M ${axisPos-40},${originY-80} Q ${axisPos},${originY+10} ${axisPos+40},${originY-80}`;
            return `<svg viewBox="0 0 ${viewBoxWidth} ${viewBoxHeight}" width="240" height="170" style="border:1px solid #ccc;border-radius:4px;"><text x="50%" y="18" text-anchor="middle" font-size="14" font-weight="bold" fill="#005a9c">${label}</text><line x1="10" y1="${originY}" x2="${viewBoxWidth-10}" y2="${originY}" stroke="#333"/><line x1="${originX}" y1="25" x2="${originX}" y2="${viewBoxHeight-20}" stroke="#333"/><text x="${viewBoxWidth-15}" y="${originY-4}">x</text><text x="${originX+4}" y="35">y</text><path d="${parabolaPath}" stroke="#007bff" stroke-width="2" fill="none"/><line x1="${axisPos}" y1="30" x2="${axisPos}" y2="${originY+5}" stroke="#d9534f" stroke-width="1.5" stroke-dasharray="4 2"/><text x="${axisPos}" y="${originY+15}" text-anchor="middle" font-size="12" fill="#d9534f">${caseText}</text><rect x="${domainPos.start}" y="${originY-3}" width="${domainPos.end-domainPos.start}" height="6" fill="#28a745" opacity="0.7"/><text x="${domainPos.start}" y="${originY+15}" text-anchor="middle">${domainStartLabel}</text><text x="${domainPos.end}" y="${originY+15}" text-anchor="middle">${domainEndLabel}</text></svg>`;
        }
        
        function generateProblem(type) {
            let question = '', choices = [], answer = '', explanation = '', graphParams = [];
            const p = 2; const down = Math.random() < 0.5; const funcSymbol = down ? `-` : ``; const funcSign = down ? -1 : 1; 
            const askForMax = Math.random() < 0.5; const minMaxText = askForMax ? '最大値' : '最小値';
            const isStandardProblem = (down && askForMax) || (!down && !askForMax); 

            if (type === 'moving_axis') {
                const b_coeff_is_odd = Math.random() < 0.8;
                const x_term_coeff = b_coeff_is_odd ? p : 2 * p; const axis_frac_latex = b_coeff_is_odd ? `\\frac{a}{${p}}` : `a`; const axis_text_svg = b_coeff_is_odd ? `a/${p}` : `a`;
                const x1 = Math.floor(Math.random() * 3) + 1; const x2 = x1 + Math.floor(Math.random() * 3) + 2;
                const const_term = Math.floor(Math.random() * 5);
                const funcExpr = `y = ${funcSymbol}${p}x^2 - ${x_term_coeff}ax ${const_term > 0 ? `+ ${const_term}`: ''}`;
                question = `関数 \\( ${funcExpr} \\) の定義域 \\( ${x1} \\le x \\le ${x2} \\) における${minMaxText}の場合分けを答えよ。`;
                
                if (isStandardProblem) {
                    const bound1 = b_coeff_is_odd ? p * x1 : x1; const bound2 = b_coeff_is_odd ? p * x2 : x2;
                    answer = `\\( a < ${bound1} \\), \\( ${bound1} \\le a \\le ${bound2} \\), \\( a > ${bound2} \\)`;
                    choices = [ answer, `\\( a < \\frac{${x1+x2}}{2}, \\ a \\ge \\frac{${x1+x2}}{2} \\)`, `\\( a < 0, \\ a \\ge 0 \\)`, `\\( a < ${bound1}, \\ a > ${bound2} \\)` ];
                    const y_val_x1 = `${formatTerm(funcSign*p*x1*x1 + const_term, '', true)}${formatTerm(-x_term_coeff*x1, 'a')}`;
                    const y_val_x2 = `${formatTerm(funcSign*p*x2*x2 + const_term, '', true)}${formatTerm(-x_term_coeff*x2, 'a')}`;
                    explanation = `<h4>考え方</h4><p>軸 \\(x=${axis_frac_latex}\\) が定義域の<b>左、中、右</b>にあるかで場合分け。</p>
                        <ol><li><b>軸 < ${x1}</b>: ${minMaxText}は \\(x=${x1}\\) で、値は \\(${y_val_x1}\\)</li>
                        <li><b>${x1} ≤ 軸 ≤ ${x2}</b>: ${minMaxText}は頂点。</li>
                        <li><b>軸 > ${x2}</b>: ${minMaxText}は \\(x=${x2}\\) で、値は \\(${y_val_x2}\\)</li></ol>`;
                    graphParams = [ { down, axisPos: 60, domainPos: {start: 90, end: 150}, label: `軸 < 左端`, caseText: `x=${axis_text_svg}`, domainStartLabel: x1, domainEndLabel: x2 }, { down, axisPos: 120, domainPos: {start: 90, end: 150}, label: `軸が定義域内`, caseText: `x=${axis_text_svg}`, domainStartLabel: x1, domainEndLabel: x2 }, { down, axisPos: 180, domainPos: {start: 90, end: 150}, label: `軸 > 右端`, caseText: `x=${axis_text_svg}`, domainStartLabel: x1, domainEndLabel: x2 } ];
                } else {
                    const midpoint = (x1 + x2) / 2; const bound = b_coeff_is_odd ? p * midpoint : midpoint;
                    answer = `\\( a < ${bound} \\), \\( a = ${bound} \\), \\( a > ${bound} \\)`;
                    choices = [ answer, `\\( a < ${x1} \\), \\( ${x1} \\le a \\le ${x2} \\), \\( a > ${x2} \\)`, `場合分けは不要`, `\\( a < ${x2} \\), \\( a \\ge ${x2} \\)` ];
                    explanation = `<h4>考え方(${minMaxText})</h4><p>頂点から<b>最も遠い定義域の端</b>が${minMaxText}となる。軸 \\(x=${axis_frac_latex}\\) と定義域の中央 \\(x=${midpoint}\\) の位置関係で場合分け。</p>`;
                    graphParams = [ { down, axisPos: 100, domainPos: {start: 90, end: 150}, label: `軸 < 中央`, caseText: `x=${axis_text_svg}`, domainStartLabel: x1, domainEndLabel: x2 }, { down, axisPos: 120, domainPos: {start: 90, end: 150}, label: `軸 = 中央`, caseText: `x=${axis_text_svg}`, domainStartLabel: x1, domainEndLabel: x2 }, { down, axisPos: 140, domainPos: {start: 90, end: 150}, label: `軸 > 中央`, caseText: `x=${axis_text_svg}`, domainStartLabel: x1, domainEndLabel: x2 } ];
                }
            } else if (type === 'moving_domain_right') {
                const x1 = Math.floor(Math.random() * 3)+1; const axis_x = x1 + Math.floor(Math.random() * 3) + 2; const vertex_y = Math.floor(Math.random() * 5); const funcExprFull = `y = ${funcSymbol}${p}(x-${axis_x})^2 ${vertex_y > 0 ? `+ ${vertex_y}`: ''}`;
                question = `関数 \\( ${funcExprFull} \\) の定義域 \\( ${x1} \\le x \\le a \\) (\\( a > ${x1} \\)) における${minMaxText}の場合分けを答えよ。`;
                if (isStandardProblem) {
                    answer = `\\( ${x1} < a < ${axis_x} \\), \\( a \\ge ${axis_x} \\)`; 
                    choices = [ answer, `\\( a < \\frac{${x1+axis_x}}{2}, \\ a \\ge \\frac{${x1+axis_x}}{2} \\)`, `\\( a > ${axis_x} \\)`, `\\( a < ${x1} \\)` ];
                    explanation = `<h4>考え方</h4><p><b>定義域に軸 \\(x=${axis_x}\\) が含まれるか</b>で場合分け。</p>
                        <ol><li><b>${x1} < a < ${axis_x}</b>: ${minMaxText}は \\(x=a\\)</li>
                        <li><b>a ≥ ${axis_x}</b>: ${minMaxText}は頂点 \\(x=${axis_x}\\)</li></ol>`;
                    graphParams = [ { down, axisPos: 150, domainPos: {start: 80, end: 120}, label: `a < 軸`, caseText: `x=${axis_x}`, domainStartLabel: x1, domainEndLabel: 'a' }, { down, axisPos: 150, domainPos: {start: 80, end: 180}, label: `a ≥ 軸`, caseText: `x=${axis_x}`, domainStartLabel: x1, domainEndLabel: 'a' } ];
                } else {
                    const symmetric_point = 2 * axis_x - x1;
                    answer = `\\( ${x1} < a < ${symmetric_point} \\), \\( a = ${symmetric_point} \\), \\( a > ${symmetric_point} \\)`;
                    choices = [answer, `\\( a < ${axis_x} \\), \\( a \\ge ${axis_x} \\)`, `\\( a < ${x1} \\), \\( a > ${x1} \\)`, `場合分けは不要`];
                    explanation = `<h4>考え方(${minMaxText})</h4><p><b>定義域の両端 \\(${x1}, a\\) のどちらが軸 \\(x=${axis_x}\\) から遠いか</b>で場合分け。</p>`;
                    graphParams = [ { down, axisPos: 150, domainPos: {start: 80, end: 120}, label: `左端が遠い`, caseText: `x=${axis_x}`, domainStartLabel: x1, domainEndLabel: 'a' }, { down, axisPos: 150, domainPos: {start: 80, end: 220}, label: `右端が遠い`, caseText: `x=${axis_x}`, domainStartLabel: x1, domainEndLabel: 'a' } ];
                }
            } else { // 他のタイプも同様の完全なロジックで生成
                const k = Math.floor(Math.random() * 3) + 2; const funcExpr = `y = (x-a)^2`;
                question = `(応用) 関数 \\( ${funcExpr} \\) の定義域 \\( 0 \\le x \\le a+${k} \\) (\\(a>0\\)) における最大値の場合分けを答えよ。`;
                answer = `\\( 0 < a < ${k} \\), \\( a = ${k} \\), \\( a > ${k} \\)`; 
                choices = [ answer, `\\( a < ${k}/2, \\ a \\ge ${k}/2 \\)`, `\\( a < ${k}, \\ a > ${k} \\)`, `\\( a > 0 \\)` ];
                explanation = `<h4>考え方</h4><p>軸は \\(x=a\\)。最大値は<b>軸から遠い方の端点</b>でとる。軸と両端 (\\(0, a+${k}\\)) の距離 \\(a\\) と \\(${k}\\) で場合分け。</p>`;
                graphParams = [ { down: false, axisPos: 100, domainPos: {start: 70, end: 170}, label: `a < ${k}`, caseText: 'x=a', domainStartLabel: '0', domainEndLabel: `a+${k}` }];
            }
            while (choices.length < 4) { choices.push(`ダミー選択肢`); } // 選択肢が4つ未満の場合の保険
            return { type, question, choices, answer, explanation, graphParams };
        }

        function startQuiz() {
            if (document.getElementById('name').value.trim() === '') { alert('ニックネームを入力してください。'); return; }
            totalTime = 0; score = 0; currentQuestionIndex = 0; quizData = [];
            const shuffledTypes = [...problemTypes].sort(() => 0.5 - Math.random());
            for (let i = 0; i < TOTAL_QUESTIONS; i++) { quizData.push(generateProblem(shuffledTypes[i % shuffledTypes.length])); }
            setupDiv.classList.add('hidden'); problemContainer.classList.remove('hidden'); timerDisplay.classList.remove('hidden');
            displayQuestion();
        }

        function displayQuestion() {
            explanationDiv.classList.add('hidden'); nextQuestionBtn.classList.add('hidden');
            const problem = quizData[currentQuestionIndex];
            problemHeader.textContent = `第 ${currentQuestionIndex + 1} 問 / ${TOTAL_QUESTIONS} 問`;
            problemStatement.innerHTML = problem.question; renderMath(problemStatement);
            optionsContainer.innerHTML = '';
            const shuffledChoices = problem.choices.sort(() => 0.5 - Math.random());
            shuffledChoices.forEach(choice => { const button = document.createElement('button'); button.className = 'option-btn'; button.innerHTML = choice; button.onclick = (event) => checkAnswer(choice, event.currentTarget); optionsContainer.appendChild(button); });
            renderMath(optionsContainer);
            startTimer();
        }
        
        function checkAnswer(selectedChoice, selectedButton) {
            stopTimer(); const problem = quizData[currentQuestionIndex];
            if (selectedChoice === problem.answer) { score++; resultMessage.textContent = "正解！"; resultMessage.style.color = 'green'; } else { resultMessage.textContent = "不正解..."; resultMessage.style.color = 'red'; }
            Array.from(optionsContainer.children).forEach(btn => { btn.disabled = true; if (btn.innerHTML === problem.answer) { btn.classList.add('correct'); } else if (btn === selectedButton) { btn.classList.add('incorrect'); } });
            showExplanation(problem); nextQuestionBtn.classList.remove('hidden');
            if (currentQuestionIndex === TOTAL_QUESTIONS - 1) { nextQuestionBtn.textContent = '結果を見る'; }
        }

        function showExplanation(problem) {
            explanationProblemStatement.innerHTML = "<h4>問題</h4>" + problem.question; renderMath(explanationProblemStatement);
            explanationTextDiv.innerHTML = problem.explanation; renderMath(explanationTextDiv);
            explanationGraphsDiv.innerHTML = '';
            if (problem.graphParams && problem.graphParams.length > 0) {
                problem.graphParams.forEach(params => { const svgContainer = document.createElement('div'); svgContainer.innerHTML = createSVGGraph(params); explanationGraphsDiv.appendChild(svgContainer); });
            }
            explanationDiv.classList.remove('hidden');
        }

        function nextQuestion() { currentQuestionIndex++; if (currentQuestionIndex < TOTAL_QUESTIONS) { displayQuestion(); } else { showFinalResults(); } }
        function showFinalResults() {
            problemContainer.classList.add('hidden'); timerDisplay.classList.add('hidden');
            finalResultContainer.classList.remove('hidden');
            finalTime.textContent = totalTime.toFixed(2);
            finalScore.textContent = `${score} 点`;
            recordToSheet();
        }

        function recordToSheet() {
            const name = document.getElementById('name').value;
            const GAS_URL = 'https://script.google.com/macros/s/AKfycbwXkwNnWEJ84urMGCwQgVrycf5ictFI9S0GGH29JNh4d7LuII7fzC4oNPkftqQ1hZPLIw/exec'; 
            if (GAS_URL.includes('貼り付け')) { console.log('GASのURLが設定されていません。'); return; }
            const data = { name: name, time: totalTime, score: score, timestamp: new Date().toISOString() };
            fetch(GAS_URL, { method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }).catch(console.error);
        }

        function startTimer() { startTime = Date.now(); timerInterval = setInterval(() => { timerDisplay.textContent = ((Date.now() - startTime) / 1000 + totalTime).toFixed(2); }, 100); }
        function stopTimer() { clearInterval(timerInterval); totalTime += (Date.now() - startTime) / 1000; }
        startBtn.addEventListener('click', startQuiz); nextQuestionBtn.addEventListener('click', nextQuestion);
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>